<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>direct_s3.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>direct_s3.md
</h1>
<div class='paths'>
doc/direct_s3.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2021-06-14 23:14:24 +0200</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>— id: direct-s3</p>

<h2 id="label-title-3A+Direct+Uploads+to+S3">title: Direct Uploads to S3<span><a href="#label-title-3A+Direct+Uploads+to+S3">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> gives you the ability to upload files directly to Amazon S3 (or any other storage service that accepts direct uploads). Uploading directly to a storage service is beneficial for several reasons:</p>
<ul><li>
<p>Accepting uploads is resource-intensive for the server, and delegating it to  an external service makes scaling easier.</p>
</li><li>
<p>If both temporary and permanent storage are S3, promoting an S3 file to  permanent storage will simply issue an S3 copy request, without any  downloading and reuploading.</p>
</li><li>
<p>With multiple servers it&#39;s generally not possible to cache files to the disk,  unless you&#39;re using a distibuted filesystem that&#39;s shared between servers.</p>
</li><li>
<p>On Heroku any uploaded files that aren&#39;t part of version control don&#39;t persist,  they get removed each time you do a new deploy or when the dyno automatically  changes the location.</p>
</li><li>
<p>If your request workers have a timeout configured or you&#39;re using Heroku,  uploading large files to S3 or any external service inside the  request-response lifecycle might not be able to finish before the request  times out.</p>
</li></ul>

<h2 id="label-Storage">Storage<span><a href="#label-Storage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To start, let&#39;s set both temporary and permanent storage to S3, with the temporary storage uploading to the <code>cache/</code> prefix:</p>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;shrine&quot;</span>, <span class="ruby-string">&quot;~&gt; 3.0&quot;</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;aws-sdk-s3&quot;</span>, <span class="ruby-string">&quot;~&gt; 1.14&quot;</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/s3&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">s3_options</span> = {&#x000A;  <span class="ruby-value">bucket:</span>            <span class="ruby-string">&quot;&lt;YOUR BUCKET&gt;&quot;</span>, <span class="ruby-comment"># required</span>&#x000A;  <span class="ruby-value">access_key_id:</span>     <span class="ruby-string">&quot;&lt;YOUR KEY&gt;&quot;</span>,&#x000A;  <span class="ruby-value">secret_access_key:</span> <span class="ruby-string">&quot;&lt;YOUR SECRET&gt;&quot;</span>,&#x000A;  <span class="ruby-value">region:</span>            <span class="ruby-string">&quot;&lt;REGION&gt;&quot;</span>,&#x000A;}&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-value">cache:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">prefix:</span> <span class="ruby-string">&quot;cache&quot;</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">s3_options</span>),&#x000A;  <span class="ruby-value">store:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">**</span><span class="ruby-identifier">s3_options</span>),&#x000A;}</pre>

<h2 id="label-Bucket+CORS+configuration">Bucket CORS configuration<span><a href="#label-Bucket+CORS+configuration">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In order to be able upload files directly to your S3 bucket, you&#39;ll need to update your bucket&#39;s CORS configuration, as public uploads are not allowed by default. You can do that from the AWS S3 Console by going to your bucket, clicking on the “Permissions” tab and then on “CORS Configuration”.</p>

<p>If you&#39;re using <a href="https://uppy.io">Uppy</a>, this is the recommended CORS configuration for the <a href="https://uppy.io/docs/aws-s3/">AWS S3 plugin</a> that should work for both POST and PUT uploads:</p>

<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#x000A;&lt;CORSConfiguration xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;&#x000A;  &lt;CORSRule&gt;&#x000A;    &lt;AllowedOrigin&gt;https://my-app.com&lt;/AllowedOrigin&gt;&#x000A;    &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt;&#x000A;    &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt;&#x000A;    &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt;&#x000A;    &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;&#x000A;    &lt;AllowedHeader&gt;Authorization&lt;/AllowedHeader&gt;&#x000A;    &lt;AllowedHeader&gt;x-amz-date&lt;/AllowedHeader&gt;&#x000A;    &lt;AllowedHeader&gt;x-amz-content-sha256&lt;/AllowedHeader&gt;&#x000A;    &lt;AllowedHeader&gt;content-type&lt;/AllowedHeader&gt;&#x000A;    &lt;AllowedHeader&gt;content-disposition&lt;/AllowedHeader&gt;&#x000A;    &lt;ExposeHeader&gt;ETag&lt;/ExposeHeader&gt;&#x000A;  &lt;/CORSRule&gt;&#x000A;  &lt;CORSRule&gt;&#x000A;    &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;&#x000A;    &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt;&#x000A;    &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;&#x000A;  &lt;/CORSRule&gt;&#x000A;&lt;/CORSConfiguration&gt;</pre>

<p>Or in JSON format:</p>

<pre class="ruby">[&#x000A;    {&#x000A;        <span class="ruby-value">&quot;AllowedOrigins&quot;:</span> [ <span class="ruby-string">&quot;https://my-app.com&quot;</span> ],&#x000A;        <span class="ruby-value">&quot;AllowedMethods&quot;:</span> [ <span class="ruby-string">&quot;GET&quot;</span>, <span class="ruby-string">&quot;POST&quot;</span>, <span class="ruby-string">&quot;PUT&quot;</span> ],&#x000A;        <span class="ruby-value">&quot;MaxAgeSeconds&quot;:</span> <span class="ruby-value">3000</span>,&#x000A;        <span class="ruby-value">&quot;AllowedHeaders&quot;:</span> [&#x000A;            <span class="ruby-string">&quot;Authorization&quot;</span>,&#x000A;            <span class="ruby-string">&quot;x-amz-date&quot;</span>,&#x000A;            <span class="ruby-string">&quot;x-amz-content-sha256&quot;</span>,&#x000A;            <span class="ruby-string">&quot;Content-Type&quot;</span>,&#x000A;            <span class="ruby-string">&quot;Content-Disposition&quot;</span>&#x000A;        ],&#x000A;        <span class="ruby-value">&quot;ExposeHeaders&quot;:</span> [ <span class="ruby-string">&quot;ETag&quot;</span> ]&#x000A;    },&#x000A;    {&#x000A;        <span class="ruby-value">&quot;AllowedOrigins&quot;:</span> [ <span class="ruby-string">&quot;*&quot;</span> ],&#x000A;        <span class="ruby-value">&quot;AllowedMethods&quot;:</span> [ <span class="ruby-string">&quot;GET&quot;</span> ],&#x000A;        <span class="ruby-value">&quot;MaxAgeSeconds&quot;:</span> <span class="ruby-value">3000</span>&#x000A;    }&#x000A;]</pre>

<p>Replace <code>https://my-app.com</code> with the URL to your app (in development you can set this to <code>*</code>). Once you&#39;ve hit “Save”, it may take some time for the new CORS settings to be applied.</p>

<h2 id="label-Strategy+A+-28dynamic-29">Strategy A (dynamic)<span><a href="#label-Strategy+A+-28dynamic-29">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>Best user experience</p>
</li><li>
<p>Single or multiple file uploads</p>
</li><li>
<p>Some JavaScript needed</p>
</li></ul>

<p>When the user selects a file in the form, on the client side we asynchronously fetch the upload parameters from the server, and use it to upload the file to S3. It&#39;s recommended to use <a href="https://uppy.io">Uppy</a> for client side uploads.</p>

<p>The <code>presign_endpoint</code> plugin provides a Rack application that generates these upload parameters, which we can just mount in our application. We&#39;ll make our presign endpoint also use the additional <code>type</code> and <code>filename</code> query parameters to set <code>Content-Type</code> header, <code>Content-Disposition</code> header (using the <a href="https://github.com/shrinerb/content_disposition">content_disposition</a> gem), as well as limit the upload size to 10 MB (see {<code>Shrine::Storage::S3#presign</code><a href="https://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html#method-i-presign">}</a> for the list of available options).</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:presign_endpoint</span>, <span class="ruby-value">presign_options:</span> <span class="ruby-operator">-&gt;</span> (<span class="ruby-identifier">request</span>) {&#x000A;  <span class="ruby-comment"># Uppy will send the &quot;filename&quot; and &quot;type&quot; query parameters</span>&#x000A;  <span class="ruby-identifier">filename</span> = <span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>[<span class="ruby-string">&quot;filename&quot;</span>]&#x000A;  <span class="ruby-identifier">type</span>     = <span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>[<span class="ruby-string">&quot;type&quot;</span>]&#x000A;&#x000A;  {&#x000A;    <span class="ruby-value">content_disposition:</span>    <span class="ruby-constant">ContentDisposition</span>.<span class="ruby-identifier">inline</span>(<span class="ruby-identifier">filename</span>), <span class="ruby-comment"># set download filename</span>&#x000A;    <span class="ruby-value">content_type:</span>           <span class="ruby-identifier">type</span>,                                <span class="ruby-comment"># set content type (required if using DigitalOcean Spaces)</span>&#x000A;    <span class="ruby-value">content_length_range:</span>   <span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-value">10</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>),                   <span class="ruby-comment"># limit upload size to 10 MB</span>&#x000A;  }&#x000A;}</pre>

<pre class="ruby"><span class="ruby-comment"># config/routes.rb (Rails)</span>&#x000A;<span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">presign_endpoint</span>(<span class="ruby-value">:cache</span>) <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;/s3/params&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>The above will create a <code>GET /s3/params</code> route, which internally calls {<code>Shrine::Storage::S3#presign</code><a href="https://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html#method-i-presign">}</a> to return the HTTP verb (POST) and the S3 URL to which the file should be uploaded, along with the required POST parameters and request headers.</p>

<pre class="ruby"><span class="ruby-comment"># GET /s3/params</span>&#x000A;{&#x000A;  <span class="ruby-value">&quot;method&quot;:</span> <span class="ruby-string">&quot;post&quot;</span>,&#x000A;  <span class="ruby-value">&quot;url&quot;:</span> <span class="ruby-string">&quot;https://my-bucket.s3-eu-west-1.amazonaws.com&quot;</span>,&#x000A;  <span class="ruby-value">&quot;fields&quot;:</span> {&#x000A;    <span class="ruby-value">&quot;key&quot;:</span> <span class="ruby-string">&quot;b7d575850ba61b44c8a9ff889dfdb14d88cdc25f8dd121004c8&quot;</span>,&#x000A;    <span class="ruby-value">&quot;policy&quot;:</span> <span class="ruby-string">&quot;eyJleHBpcmF0aW9uIjoiMjAxNS0QwMToxMToyOVoiLCJjb25kaXRpb25zIjpbeyJidWNrZXQiOiJ...&quot;</span>,&#x000A;    <span class="ruby-value">&quot;x-amz-credential&quot;:</span> <span class="ruby-string">&quot;AKIAIJF55TMZYT6Q/20151024/eu-west-1/s3/aws4_request&quot;</span>,&#x000A;    <span class="ruby-value">&quot;x-amz-algorithm&quot;:</span> <span class="ruby-string">&quot;AWS4-HMAC-SHA256&quot;</span>,&#x000A;    <span class="ruby-value">&quot;x-amz-date&quot;:</span> <span class="ruby-string">&quot;20151024T001129Z&quot;</span>,&#x000A;    <span class="ruby-value">&quot;x-amz-signature&quot;:</span> <span class="ruby-string">&quot;c1eb634f83f96b69bd675f535b3ff15ae184b102fcba51e4db5f4959b4ae26f4&quot;</span>&#x000A;  },&#x000A;  <span class="ruby-value">&quot;headers&quot;:</span> {}&#x000A;}</pre>

<p>Uppy&#39;s <a href="https://uppy.io/docs/aws-s3/">AWS S3</a> plugin would then make a request to this endpoint and use these parameters to upload the file directly to S3. Once the file has been uploaded, you can generate a JSON representation of the uploaded file on the client side, and write it to the hidden attachment field (or send it directly in an AJAX request).</p>

<pre class="ruby">{&#x000A;  <span class="ruby-value">&quot;id&quot;:</span> <span class="ruby-string">&quot;302858ldg9agjad7f3ls.jpg&quot;</span>,&#x000A;  <span class="ruby-value">&quot;storage&quot;:</span> <span class="ruby-string">&quot;cache&quot;</span>,&#x000A;  <span class="ruby-value">&quot;metadata&quot;:</span> {&#x000A;    <span class="ruby-value">&quot;size&quot;:</span> <span class="ruby-value">943483</span>,&#x000A;    <span class="ruby-value">&quot;filename&quot;:</span> <span class="ruby-string">&quot;nature.jpg&quot;</span>,&#x000A;    <span class="ruby-value">&quot;mime_type&quot;:</span> <span class="ruby-string">&quot;image/jpeg&quot;</span>,&#x000A;  }&#x000A;}</pre>
<ul><li>
<p><code>id</code> – location of the file on S3 (minus the <code>:prefix</code>)</p>
</li><li>
<p><code>storage</code> – direct uploads typically use the <code>:cache</code> storage</p>
</li><li>
<p><code>metadata</code> – hash of metadata extracted from the file</p>
</li></ul>

<p>Once the form is submitted, this JSON data will then be assigned to the attachment attribute instead of the raw file. See <a href="https://github.com/shrinerb/shrine/wiki/Adding-Direct-S3-Uploads">this walkthrough</a> for adding dynamic direct S3 uploads from scratch, as well as the <a href="https://github.com/shrinerb/shrine/tree/master/demo">Roda</a> / <a href="https://github.com/erikdahlstrand/shrine-rails-example">Rails</a> demo app for a complete example of multiple direct S3 uploads.</p>

<p>Also, if you&#39;re dealing with larger files, you may want to make the uploads resumable by using the <a href="https://uppy.io/docs/aws-s3/">AWS S3 Multipart</a> Uppy plugin instead, with the <a href="https://github.com/janko/uppy-s3_multipart">uppy-s3_multipart</a> gem on the backend. Your back-end implementation is similar, just using <code>Shrine.uppy_s3_multipart</code> in place of <code>Shrine.presign_endpoint</code>. Instructions can be found in the <a href="https://github.com/janko/uppy-s3_multipart#shrine">gem docs</a>.</p>

<h2 id="label-Strategy+B+-28static-29">Strategy B (static)<span><a href="#label-Strategy+B+-28static-29">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>Basic user experience</p>
</li><li>
<p>Only for single uploads</p>
</li><li>
<p>No JavaScript needed</p>
</li></ul>

<p>An alternative to the previous strategy is to generate an S3 upload form on page render. The user can then select a file and submit it directly to S3. For generating the form can use {<code>Shrine::Storage::S3#presign</code><a href="https://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html#method-i-presign">}</a>, which returns URL and form fields that should be used for the upload.</p>

<pre class="ruby"><span class="ruby-identifier">presign_data</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[<span class="ruby-value">:cache</span>].<span class="ruby-identifier">presign</span>(&#x000A;  <span class="ruby-constant">SecureRandom</span>.<span class="ruby-identifier">hex</span>,&#x000A;  <span class="ruby-value">success_action_redirect:</span> <span class="ruby-identifier">new_album_url</span>&#x000A;)&#x000A;&#x000A;<span class="ruby-identifier">form</span> <span class="ruby-value">action:</span> <span class="ruby-identifier">presign_data</span>[<span class="ruby-value">:url</span>], <span class="ruby-value">method:</span> <span class="ruby-string">&quot;post&quot;</span>, <span class="ruby-value">enctype:</span> <span class="ruby-string">&quot;multipart/form-data&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">presign_data</span>[<span class="ruby-value">:fields</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:hidden</span>, <span class="ruby-value">name:</span> <span class="ruby-identifier">name</span>, <span class="ruby-value">value:</span> <span class="ruby-identifier">value</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:file</span>, <span class="ruby-value">name:</span> <span class="ruby-string">&quot;file&quot;</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span> <span class="ruby-string">&quot;Submit&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Note the additional <code>:success_action_redirect</code> option which tells S3 where to redirect to after the file has been uploaded. If you&#39;re using the Rails form builder to generate this form, you might need to also tell S3 to ignore the additional <code>utf8</code> and <code>authenticity_token</code> fields that Rails generates:</p>

<pre class="ruby"><span class="ruby-identifier">presign_data</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[<span class="ruby-value">:cache</span>].<span class="ruby-identifier">presign</span>(&#x000A;  <span class="ruby-constant">SecureRandom</span>.<span class="ruby-identifier">hex</span>,&#x000A;  <span class="ruby-value">allow_any:</span> [<span class="ruby-string">&quot;utf8&quot;</span>, <span class="ruby-string">&quot;authenticity_token&quot;</span>],&#x000A;  <span class="ruby-value">success_action_redirect:</span> <span class="ruby-identifier">new_album_url</span>&#x000A;)&#x000A;&#x000A;<span class="ruby-comment"># ...</span></pre>

<p>Let&#39;s assume we specified the redirect URL to be a page which renders the form for a new record. S3 will include some information about the upload in form of GET parameters in the URL, out of which we only need the <code>key</code> parameter:</p>

<pre class="ruby"><span class="ruby-identifier">cached_file</span> = {&#x000A;  <span class="ruby-value">storage:</span> <span class="ruby-string">&quot;cache&quot;</span>,&#x000A;  <span class="ruby-value">id:</span> <span class="ruby-identifier">params</span>[<span class="ruby-string">&quot;key&quot;</span>][<span class="ruby-regexp">/^cache\/(.+)/</span>, <span class="ruby-value">1</span>], <span class="ruby-comment"># we subtract the storage prefix</span>&#x000A;  <span class="ruby-value">metadata:</span> {},&#x000A;}&#x000A;&#x000A;<span class="ruby-identifier">form</span> <span class="ruby-ivar">@album</span>, <span class="ruby-value">action:</span> <span class="ruby-string">&quot;/albums&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:image</span>, <span class="ruby-value">type:</span> <span class="ruby-value">:hidden</span>, <span class="ruby-value">value:</span> <span class="ruby-identifier">cached_file</span>.<span class="ruby-identifier">to_json</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span> <span class="ruby-string">&quot;Save&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Shrine+metadata"><a href="../../classes/Shrine.html"><code>Shrine</code></a> metadata<span><a href="#label-Shrine+metadata">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When attaching a file that was uploaded directly to S3, by default <a href="../../classes/Shrine.html"><code>Shrine</code></a> will not extract metadata from the file, instead it will simply copy over any metadata assigned on the client side. This is the default behaviour because extracting metadata requires retrieving file content, which in this case means additional HTTP requests.</p>

<p>See <a href="https://shrinerb.com/docs/metadata#direct-uploads">this section</a> or the rationale and instructions on how to opt in.</p>

<h2 id="label-Clearing+cache">Clearing cache<span><a href="#label-Clearing+cache">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Directly uploaded files won&#39;t automatically be deleted from your temporary storage, so you&#39;ll want to periodically clear them. One way to do that is by setting up recurring script which calls <code>Shrine::Storage::S3#clear!</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s3</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[<span class="ruby-value">:cache</span>]&#x000A;<span class="ruby-identifier">s3</span>.<span class="ruby-identifier">clear!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">object</span><span class="ruby-operator">|</span> <span class="ruby-identifier">object</span>.<span class="ruby-identifier">last_modified</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span><span class="ruby-operator">*</span><span class="ruby-value">24</span><span class="ruby-operator">*</span><span class="ruby-value">60</span><span class="ruby-operator">*</span><span class="ruby-value">60</span> } <span class="ruby-comment"># delete files older than 1 week</span></pre>

<p>Alternatively you can add a bucket lifeycle rule to do this for you. This can be done either from the <a target="_top" href="http://docs.aws.amazon.com/AmazonS3/latest/UG/lifecycle-configuration-bucket-no-versioning.html">AWS Console</a> or via an <a href="https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/S3/Client.html#put_bucket_lifecycle_configuration-instance_method">API call</a>:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;aws-sdk-s3&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">client</span> = <span class="ruby-constant">Aws</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span><span class="ruby-operator">::</span><span class="ruby-constant">Client</span>.<span class="ruby-identifier">new</span>(&#x000A;  <span class="ruby-value">access_key_id:</span>     <span class="ruby-string">&quot;&lt;YOUR KEY&gt;&quot;</span>,&#x000A;  <span class="ruby-value">secret_access_key:</span> <span class="ruby-string">&quot;&lt;YOUR SECRET&gt;&quot;</span>,&#x000A;  <span class="ruby-value">region:</span>            <span class="ruby-string">&quot;&lt;REGION&gt;&quot;</span>,&#x000A;)&#x000A;&#x000A;<span class="ruby-identifier">client</span>.<span class="ruby-identifier">put_bucket_lifecycle_configuration</span>(&#x000A;  <span class="ruby-value">bucket:</span> <span class="ruby-string">&quot;&lt;YOUR BUCKET&gt;&quot;</span>,&#x000A;  <span class="ruby-value">lifecycle_configuration:</span> {&#x000A;    <span class="ruby-value">rules:</span> [{&#x000A;      <span class="ruby-value">expiration:</span> { <span class="ruby-value">days:</span> <span class="ruby-value">7</span> },&#x000A;      <span class="ruby-value">filter:</span> { <span class="ruby-value">prefix:</span> <span class="ruby-string">&quot;cache/&quot;</span> },&#x000A;      <span class="ruby-value">id:</span> <span class="ruby-string">&quot;cache-clear&quot;</span>,&#x000A;      <span class="ruby-value">status:</span> <span class="ruby-string">&quot;Enabled&quot;</span>&#x000A;    }]&#x000A;  }&#x000A;)</pre>

<h2 id="label-Eventual+consistency">Eventual consistency<span><a href="#label-Eventual+consistency">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When uploading objects to Amazon S3, sometimes they may not be available immediately. This can be a problem when using direct S3 uploads, because usually in this case you&#39;re using S3 for both cache and store, so the S3 object is moved to store soon after caching.</p>

<blockquote>
<p>Amazon S3 provides eventual consistency for some operations, so it is possible that new data will not be available immediately after the upload, which could result in an incomplete data load or loading stale data. COPY operations where the cluster and the bucket are in different regions are eventually consistent. All regions provide read-after-write consistency for uploads of new objects with unique object keys. For more information about data consistency, see <a target="_top" href="http://docs.aws.amazon.com/AmazonS3/latest/dev/Introduction.html#ConsistencyMode">Amazon S3 Data Consistency Model</a> in the <em>Amazon Simple Storage Service Developer Guide</em>.</p>
</blockquote>

<p>This means that in certain cases copying from cache to store can fail if it happens immediately after uploading to cache. If you start noticing these errors, and you&#39;re using <code>backgrounding</code> plugin, you can tell your backgrounding library to perform the job with a delay:</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:backgrounding</span>&#x000A;&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote_block</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># tells a Sidekiq worker to perform in 3 seconds</span>&#x000A;  <span class="ruby-constant">PromoteJob</span>.<span class="ruby-identifier">perform_in</span>(<span class="ruby-value">3</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">record</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">record</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">file_data</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Checksums">Checksums<span><a href="#label-Checksums">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can have AWS S3 verify the integrity of the uploaded data by including a checksum generated on the client side in the upload request. For that we&#39;ll need to include the checksum in the presign request, which we can pass in via the <code>checksum</code> query parameter. The <code>:content_md5</code> parameter is not supported in POST presigns, so for this we&#39;ll need to switch to PUT.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:presign_endpoint</span>, <span class="ruby-value">presign_options:</span> <span class="ruby-operator">-&gt;</span> (<span class="ruby-identifier">request</span>) <span class="ruby-keyword">do</span>&#x000A;  {&#x000A;    <span class="ruby-value">method:</span> <span class="ruby-value">:put</span>,&#x000A;    <span class="ruby-value">content_md5:</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>[<span class="ruby-string">&quot;checksum&quot;</span>],&#x000A;  }&#x000A;<span class="ruby-keyword">end</span></pre>

<p>See <a href="https://github.com/shrinerb/shrine/wiki/Using-Checksums-in-Direct-Uploads">this walkthrough</a> for a complete JavaScript implementation of checksums.</p>

<p>Note that PUT presigns don&#39;t support the <code>:content_length_range</code> option, but they support <code>:content_length</code> instead. So, if you want to limit the upload size during direct uploads, you can pass an additional <code>size</code> query parameter to the presign request on the client side, and require it when generating presign options:</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:presign_endpoint</span>, <span class="ruby-value">presign_options:</span> <span class="ruby-operator">-&gt;</span> (<span class="ruby-identifier">request</span>) <span class="ruby-keyword">do</span>&#x000A;  {&#x000A;    <span class="ruby-value">method:</span> <span class="ruby-value">:put</span>,&#x000A;    <span class="ruby-value">content_length:</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-string">&quot;size&quot;</span>),&#x000A;    <span class="ruby-value">content_md5:</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>[<span class="ruby-string">&quot;checksum&quot;</span>],&#x000A;  }&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Testing">Testing<span><a href="#label-Testing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To avoid network requests in your test and development environment, you can use <a href="https://minio.io">Minio</a>. Minio is an open source object storage server with AWS S3 compatible API which you can run locally. See how to set it up in the <a href="https://shrinerb.com/docs/testing#minio">Testing</a> guide.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
