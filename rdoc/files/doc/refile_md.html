<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>refile.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>refile.md
</h1>
<div class='paths'>
doc/refile.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2017-09-11 13:15:18 +0200</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Shrine+for+Refile+Users"><a href="../../classes/Shrine.html">Shrine</a> for Refile Users<span><a href="#label-Shrine+for+Refile+Users">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>This guide is aimed at helping Refile users transition to <a
href="../../classes/Shrine.html">Shrine</a>, and it consists of three
parts:</p>
<ol><li>
<p>Explanation of the key differences in design between Refile and <a
href="../../classes/Shrine.html">Shrine</a></p>
</li><li>
<p>Instructions how to migrate and existing app that uses Refile to <a
href="../../classes/Shrine.html">Shrine</a></p>
</li><li>
<p>Extensive reference of Refile&#39;s interface with <a
href="../../classes/Shrine.html">Shrine</a> equivalents</p>
</li></ol>

<h2 id="label-Uploaders">Uploaders<span><a href="#label-Uploaders">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html">Shrine</a> borrows many great concepts
from Refile: Refile&#39;s “backends” are here named “storages”, it uses the
same IO abstraction for uploading and representing uploaded files, similar
attachment logic, and direct uploads are also supported.</p>

<p>While in Refile you work with storages directly, <a
href="../../classes/Shrine.html">Shrine</a> uses <em>uploaders</em> which
act as wrappers around storages:</p>

<pre class="ruby"><span class="ruby-identifier">storage</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">store</span>]&#x000A;<span class="ruby-identifier">storage</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::Storage::S3 ...&gt;</span>&#x000A;&#x000A;<span class="ruby-identifier">uploader</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">store</span>)&#x000A;<span class="ruby-identifier">uploader</span>         <span class="ruby-comment">#=&gt; #&lt;Shrine @storage_key=:store @storage=#&lt;Shrine::Storage::S3&gt;&gt;</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">storage</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::Storage::S3 ...&gt;</span>&#x000A;&#x000A;<span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">image</span>)&#x000A;<span class="ruby-identifier">uploaded_file</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span></pre>

<p>This way <a href="../../classes/Shrine.html">Shrine</a> can perform tasks
like generating location, extracting metadata, processing, and logging,
which are all storage-agnostic, and leave storages to deal only with actual
file storage. And these tasks can be configured differently depending on
the types of files you&#39;re uploading:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">add_metadata</span> :<span class="ruby-identifier">exif</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-constant">MiniMagick</span><span class="ruby-operator">::</span><span class="ruby-constant">Image</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">io</span>).<span class="ruby-identifier">exif</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">add_metadata</span> :<span class="ruby-identifier">duration</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-constant">FFMPEG</span><span class="ruby-operator">::</span><span class="ruby-constant">Movie</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">path</span>).<span class="ruby-identifier">duration</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h3 id="label-Processing">Processing<span><a href="#label-Processing">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Refile implements on-the-fly processing, serving all files through the Rack
endpoint. However, it doesn&#39;t offer any abilities for processing on
upload. <a href="../../classes/Shrine.html">Shrine</a>, on the other hand,
generates URLs to specific storages and offers processing on upload (like
CarrierWave and Paperclip), but doesn&#39;t support on-the-fly processing.</p>

<p>The reason for this decision is that an image server is a completely
separate responsibility, and it&#39;s better to use any of the generic
services for on-the-fly processing. <a
href="../../classes/Shrine.html">Shrine</a> already has integrations for
many such services: <a
href="https://github.com/janko-m/shrine-cloudinary">shrine-cloudinary</a>,
<a href="https://github.com/janko-m/shrine-imgix">shrine-imgix</a>, and <a
href="https://github.com/janko-m/shrine-uploadcare">shrine-uploadcare</a>.
There is even an open-source solution, <a
href="https://github.com/choonkeat/attache">Attache</a>, which you can also
use with <a href="../../classes/Shrine.html">Shrine</a>.</p>

<p>This is how you would process multiple versions in Shrine:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">versions</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">size_800</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>, <span class="ruby-value">800</span>, <span class="ruby-value">800</span>)&#x000A;    <span class="ruby-identifier">size_500</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">size_800</span>,    <span class="ruby-value">500</span>, <span class="ruby-value">500</span>)&#x000A;    <span class="ruby-identifier">size_300</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">size_500</span>,    <span class="ruby-value">300</span>, <span class="ruby-value">300</span>)&#x000A;&#x000A;    {<span class="ruby-identifier">original</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_800</span>, <span class="ruby-identifier">medium</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_500</span>, <span class="ruby-identifier">small</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_300</span>}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h3 id="label-URL">URL<span><a href="#label-URL">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>While Refile serves all files through the Rack endpoint mounted in your
app, <a href="../../classes/Shrine.html">Shrine</a> serves files directly
from storage services:</p>

<pre class="ruby"><span class="ruby-constant">Refile</span>.<span class="ruby-identifier">attachment_url</span>(<span class="ruby-ivar">@photo</span>, :<span class="ruby-identifier">image</span>) <span class="ruby-comment">#=&gt; &quot;/attachments/cache/50dfl833lfs0gfh.jpg&quot;</span></pre>

<pre class="ruby"><span class="ruby-ivar">@photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">url</span> <span class="ruby-comment">#=&gt; &quot;https://my-bucket.s3.amazonaws.com/cache/50dfl833lfs0gfh.jpg&quot;</span></pre>

<p>If you&#39;re using storage which don&#39;t expose files over URL (e.g. a
database storage), or you want to secure your downloads, you can also serve
files through your app using the download_endpoint plugin.</p>

<h2 id="label-Attachments">Attachments<span><a href="#label-Attachments">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>While in Refile you configure attachments by passing options to
<code>.attachment</code>, in <a href="../../classes/Shrine.html">Shrine</a>
you define all your uploading logic inside uploaders, and then generate an
attachment module with that uploader which is included into the model:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">extend</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>&#x000A;  <span class="ruby-identifier">attachment</span> :<span class="ruby-identifier">image</span>, <span class="ruby-identifier">destroy</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">sequel</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">keep_files</span>, <span class="ruby-identifier">destroyed</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">image</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<p>This way we can encapsulate all attachment logic inside a class and share
it between different models.</p>

<h3 id="label-Metadata">Metadata<span><a href="#label-Metadata">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Refile allows you to save additional metadata about uploaded files in
additional columns, so you can define
<code>&lt;attachment&gt;_filename</code>,
<code>&lt;attachment&gt;_content_type</code>, or
<code>&lt;attachment&gt;_size</code>.</p>

<p><a href="../../classes/Shrine.html">Shrine</a>, on the other hand, saves
all metadata into a single <code>&lt;attachment&gt;_data</code> column:</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   &quot;storage&quot; =&gt; &quot;store&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;id&quot; =&gt; &quot;photo/1/image/0d9o8dk42.png&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;metadata&quot; =&gt; {</span>&#x000A;<span class="ruby-comment">#     &quot;filename&quot;  =&gt; &quot;nature.png&quot;,</span>&#x000A;<span class="ruby-comment">#     &quot;size&quot;      =&gt; 49349138,</span>&#x000A;<span class="ruby-comment">#     &quot;mime_type&quot; =&gt; &quot;image/png&quot;</span>&#x000A;<span class="ruby-comment">#   }</span>&#x000A;<span class="ruby-comment"># }</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">original_filename</span> <span class="ruby-comment">#=&gt; &quot;nature.png&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">size</span>              <span class="ruby-comment">#=&gt; 49349138</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">mime_type</span>         <span class="ruby-comment">#=&gt; &quot;image/png&quot;</span></pre>

<p>By default “filename”, “size” and “mime_type” is stored, but you can also
store image dimensions, or define any other custom metadata. This also
allow storages to add their own metadata.</p>

<h3 id="label-Validations">Validations<span><a href="#label-Validations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In Refile you define validations by passing options to
<code>.attachment</code>, while in <a
href="../../classes/Shrine.html">Shrine</a> you define validations on the
instance-level, which allows them to be dynamic:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">attachment</span> :<span class="ruby-identifier">image</span>,&#x000A;    <span class="ruby-identifier">extension</span><span class="ruby-operator">:</span> <span class="ruby-node">%w[jpg jpeg png gif]</span>,&#x000A;    <span class="ruby-identifier">content_type</span><span class="ruby-operator">:</span> <span class="ruby-node">%w[image/jpeg image/png image/gif]</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_extension_inclusion</span> <span class="ruby-node">%w[jpg jpeg png gif]</span>&#x000A;    <span class="ruby-identifier">validate_mime_type_inclusion</span> <span class="ruby-node">%w[image/jpeg image/png image/gif]</span>&#x000A;    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">10</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">record</span>.<span class="ruby-identifier">admin?</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Refile extracts the MIME type from the file extension, which means it can
easily be spoofed (just give a PHP file a <code>.jpg</code> extension). <a
href="../../classes/Shrine.html">Shrine</a> has the determine_mime_type
plugin for determining MIME type from file <em>content</em>.</p>

<h3 id="label-Multiple+uploads">Multiple uploads<span><a href="#label-Multiple+uploads">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t have a built-in
solution for accepting multiple uploads, but it&#39;s actually very easy to
do manually, see the <a
href="https://github.com/janko-m/shrine/tree/master/demo">demo app</a> on
how you can do multiple uploads directly to S3.</p>

<h2 id="label-Direct+uploads">Direct uploads<span><a href="#label-Direct+uploads">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html">Shrine</a> borrows Refile&#39;s idea of
direct uploads, and ships with <code>upload_endpoint</code> and
<code>presign_endpoint</code> plugins which provide endpoints for uploading
files and generating presigns.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">upload_endpoint</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">upload_endpoint</span>(:<span class="ruby-identifier">cache</span>) <span class="ruby-comment"># Rack app that uploads files to specified storage</span>&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">upload_endpoint</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">presign_endpoint</span>(:<span class="ruby-identifier">cache</span>) <span class="ruby-comment"># Rack app that generates presigns for specified storage</span></pre>

<p>Unlike Refile, <a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t
ship with complete JavaScript which you can just include to make it work.
Instead, you&#39;re expected to use one of the excellent JavaScript
libraries for generic file uploads like <a
href="https://github.com/FineUploader/fine-uploader">FineUploader</a>, <a
href="https://github.com/enyo/dropzone">Dropzone</a> or <a
href="https://github.com/blueimp/jQuery-File-Upload">jQuery-File-Upload</a>.
See also the <a
href="http://shrinerb.com/rdoc/files/doc/direct_s3_md.html">Direct Uploads
to S3</a> guide.</p>

<h2 id="label-Migrating+from+Refile">Migrating from Refile<span><a href="#label-Migrating+from+Refile">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You have an existing app using Refile and you want to transfer it to <a
href="../../classes/Shrine.html">Shrine</a>. Let&#39;s assume we have a
<code>Photo</code> model with the “image” attachment. First we need to
create the <code>image_data</code> column for Shrine:</p>

<pre class="ruby"><span class="ruby-identifier">add_column</span> :<span class="ruby-identifier">photos</span>, :<span class="ruby-identifier">image_data</span>, :<span class="ruby-identifier">text</span></pre>

<p>Afterwards we need to make new uploads write to the <code>image_data</code>
column. This can be done by including the below module to all models that
have Refile attachments:</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">RefileShrineSynchronization</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">write_shrine_data</span>(<span class="ruby-identifier">name</span>)&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">read_attribute</span>(<span class="ruby-node">&quot;#{name}_id&quot;</span>).<span class="ruby-identifier">present?</span>&#x000A;      <span class="ruby-identifier">data</span> = {&#x000A;        <span class="ruby-identifier">storage</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">store</span>,&#x000A;        <span class="ruby-identifier">id</span><span class="ruby-operator">:</span> <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_id&quot;</span>),&#x000A;        <span class="ruby-identifier">metadata</span><span class="ruby-operator">:</span> {&#x000A;          <span class="ruby-identifier">size</span><span class="ruby-operator">:</span> (<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_size&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-node">&quot;#{name}_size&quot;</span>)),&#x000A;          <span class="ruby-identifier">filename</span><span class="ruby-operator">:</span> (<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_filename&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-node">&quot;#{name}_filename&quot;</span>)),&#x000A;          <span class="ruby-identifier">mime_type</span><span class="ruby-operator">:</span> (<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_content_type&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-node">&quot;#{name}_content_type&quot;</span>)),&#x000A;        }&#x000A;      }&#x000A;&#x000A;      <span class="ruby-identifier">write_attribute</span>(:<span class="ruby-node">&quot;#{name}_data&quot;</span>, <span class="ruby-identifier">data</span>.<span class="ruby-identifier">to_json</span>)&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-identifier">write_attribute</span>(:<span class="ruby-node">&quot;#{name}_data&quot;</span>, <span class="ruby-keyword">nil</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">attachment</span> :<span class="ruby-identifier">image</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">RefileShrineSynchronization</span>&#x000A;&#x000A;  <span class="ruby-identifier">before_save</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">write_shrine_data</span>(:<span class="ruby-identifier">image</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">changes</span>.<span class="ruby-identifier">key?</span>(:<span class="ruby-identifier">image_id</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>After you deploy this code, the <code>image_data</code> column should now
be successfully synchronized with new attachments. Next step is to run a
script which writes all existing Refile attachments to
<code>image_data</code>:</p>

<pre class="ruby"><span class="ruby-constant">Photo</span>.<span class="ruby-identifier">find_each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">photo</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">photo</span>.<span class="ruby-identifier">write_shrine_data</span>(:<span class="ruby-identifier">image</span>)&#x000A;  <span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save!</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Now you should be able to rewrite your application so that it uses <a
href="../../classes/Shrine.html">Shrine</a> instead of Refile, using
equivalent <a href="../../classes/Shrine.html">Shrine</a> storages. For
help with translating the code from Refile to <a
href="../../classes/Shrine.html">Shrine</a>, you can consult the reference
below.</p>

<h2 id="label-Refile+to+Shrine+direct+mapping">Refile to <a href="../../classes/Shrine.html">Shrine</a> direct mapping<span><a href="#label-Refile+to+Shrine+direct+mapping">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-Refile"><code>Refile</code><span><a href="#label-Refile">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-.cache-2C+.store-2C+.backends"><code>.cache</code>, <code>.store</code>, <code>.backends</code><span><a href="#label-.cache-2C+.store-2C+.backends">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p><a href="../../classes/Shrine.html">Shrine</a> calles these “storages”, and
it doesn&#39;t have special accessors for <code>:cache</code> and
<code>:store</code>:</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Foo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>),&#x000A;  <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Bar</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>),&#x000A;}</pre>

<h4 id="label-.app-2C+.mount_point-2C+.automount"><code>.app</code>, <code>.mount_point</code>, <code>.automount</code><span><a href="#label-.app-2C+.mount_point-2C+.automount">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>upload_endpoint</code> and <code>presign_endpoint</code> plugins
provide methods for generating Rack apps, but you need to mount them
explicitly:</p>

<pre class="ruby"><span class="ruby-comment"># config/routes.rb</span>&#x000A;<span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># adds `POST /images/upload` endpoint</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">upload_endpoint</span>(:<span class="ruby-identifier">cache</span>) =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;/images/upload&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h4 id="label-.allow_uploads_to"><code>.allow_uploads_to</code><span><a href="#label-.allow_uploads_to">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>Shrine.upload_endpoint</code> and
<code>Shrine.presign_endpoint</code> require you to specify the storage
that will be used.</p>

<h4 id="label-.logger"><code>.logger</code><span><a href="#label-.logger">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">logging</span></pre>

<h4 id="label-.processors-2C+.processor"><code>.processors</code>, <code>.processor</code><span><a href="#label-.processors-2C+.processor">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h4 id="label-.types"><code>.types</code><span><a href="#label-.types">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>In <a href="../../classes/Shrine.html">Shrine</a> validations are done by
calling <code>.validate</code> on the attacher class:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">5</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h4 id="label-.extract_filename-2C+.extract_content_type"><code>.extract_filename</code>, <code>.extract_content_type</code><span><a href="#label-.extract_filename-2C+.extract_content_type">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>In <a href="../../classes/Shrine.html">Shrine</a> equivalents are (private)
methods <code>Shrine#extract_filename</code> and
<code>Shrine#extract_mime_type</code>.</p>

<h4 id="label-.app_url"><code>.app_url</code><span><a href="#label-.app_url">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>You should use your framework to generate the URL to your mounted direct
enpdoint.</p>

<h4 id="label-.attachment_url-2C+.file_url"><code>.attachment_url</code>, <code>.file_url</code><span><a href="#label-.attachment_url-2C+.file_url">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>You can call <code>#url</code> on the uploaded file, or
<code>#&lt;name&gt;_url</code> on the model. Additionally you can use the
<code>download_endpoint</code> plugin.</p>

<h4 id="label-.upload_url-2C+.attachment_upload_url-2C+.presign_url-2C+.attachment_presign_url"><code>.upload_url</code>, <code>.attachment_upload_url</code>, <code>.presign_url</code>, <code>.attachment_presign_url</code><span><a href="#label-.upload_url-2C+.attachment_upload_url-2C+.presign_url-2C+.attachment_presign_url">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>These should be generated directly by you, it depends on where you&#39;ve
mounted the direct endpoint.</p>

<h4 id="label-.host-2C+.cdn_host-2C+.app_host-2C+.allow_downloads_from-2C+allow_origin-2C+.content_max_age"><code>.host</code>, <code>.cdn_host</code>, <code>.app_host</code>, <code>.allow_downloads_from</code>, <code>allow_origin</code>, <code>.content_max_age</code><span><a href="#label-.host-2C+.cdn_host-2C+.app_host-2C+.allow_downloads_from-2C+allow_origin-2C+.content_max_age">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Not needed since <a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t
offer on-the-fly processing.</p>

<h4 id="label-.secret_key-2C+.token-2C+.valid_token-3F"><code>.secret_key</code>, <code>.token</code>, <code>.valid_token?</code><span><a href="#label-.secret_key-2C+.token-2C+.valid_token-3F">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Not needed since <a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t
offer on-the-fly processing.</p>

<h3 id="label-attachment"><code>attachment</code><span><a href="#label-attachment">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Shrine&#39;s equivalent to calling the attachment is including an
attachment module of an uploader:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">User</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">avatar</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<h4 id="label-3Aextension-2C+-3Acontent_type-2C+-3Atype"><code>:extension</code>, <code>:content_type</code>, <code>:type</code><span><a href="#label-3Aextension-2C+-3Acontent_type-2C+-3Atype">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>In <a href="../../classes/Shrine.html">Shrine</a> validations are done
instance-level inside the uploader, most commonly with the
<code>validation_helpers</code> plugin:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_extension_inclusion</span> <span class="ruby-node">%w[jpg jpeg png]</span>&#x000A;    <span class="ruby-identifier">validate_mime_type_inclusion</span> <span class="ruby-node">%w[image/jpeg image/png]</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h4 id="label-3Acache-2C+-3Astore"><code>:cache</code>, <code>:store</code><span><a href="#label-3Acache-2C+-3Astore">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p><a href="../../classes/Shrine.html">Shrine</a> provides a
<code>default_storage</code> plugin for setting custom storages on the
uploader:</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">custom_cache</span>] = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Foo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">custom_store</span>] = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Bar</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)</pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">default_storage</span>, <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">custom_cache</span>, <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">custom_store</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h4 id="label-3Araise_errors"><code>:raise_errors</code><span><a href="#label-3Araise_errors">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>No equivalent currently exists in <a
href="../../classes/Shrine.html">Shrine</a>.</p>

<h3 id="label-accepts_attachments_for"><code>accepts_attachments_for</code><span><a href="#label-accepts_attachments_for">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>No equivalent in <a href="../../classes/Shrine.html">Shrine</a>, but take a
look at the “<a
href="http://shrinerb.com/rdoc/files/doc/multiple_files_md.html">Multiple
Files</a>” guide.</p>

<h3 id="label-Form+helpers">Form helpers<span><a href="#label-Form+helpers">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-attachment_field"><code>attachment_field</code><span><a href="#label-attachment_field">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The following Refile code</p>

<pre>&lt;%= form_for @user do |form| %&gt;&#x000A;  &lt;%= form.attachment_field :profile_image %&gt;&#x000A;&lt;% end %&gt;</pre>

<p>is equivalent to the following <a
href="../../classes/Shrine.html">Shrine</a> code</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">cached_attachment_data</span></pre>

<pre>&lt;%= form_for @user do |form| %&gt;&#x000A;  &lt;%= form.hidden_field :profile_image, value: @user.cached_profile_image_data %&gt;&#x000A;  &lt;%= form.file_field :profile_image %&gt;&#x000A;&lt;% end %&gt;</pre>

<h3 id="label-Model+methods">Model methods<span><a href="#label-Model+methods">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-remove_-3Cattachment-3E"><code>remove_&lt;attachment&gt;</code><span><a href="#label-remove_-3Cattachment-3E">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p><a href="../../classes/Shrine.html">Shrine</a> comes with a
<code>remove_attachment</code> plugin which adds the same
<code>#remove_&lt;attachment&gt;</code> method to the model.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">remove_attachment</span></pre>

<pre>&lt;%= form_for @user do |form| %&gt;&#x000A;  &lt;%= form.hidden_field :profile_image, value: @user.cached_profile_image_data %&gt;&#x000A;  &lt;%= form.file_field :profile_image %&gt;&#x000A;  &lt;%= form.check_box :remove_profile_image %&gt;&#x000A;&lt;% end %&gt;</pre>

<h4 id="label-remote_-3Cattachment-3E_url"><code>remote_&lt;attachment&gt;_url</code><span><a href="#label-remote_-3Cattachment-3E_url">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p><a href="../../classes/Shrine.html">Shrine</a> comes with a
<code>remote_url</code> plugin which adds the same
<code>#&lt;attachment&gt;_remote_url</code> method to the model.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">remote_url</span></pre>

<pre>&lt;%= form_for @user do |form| %&gt;&#x000A;  &lt;%= form.hidden_field :profile_image, value: @user.cached_profile_image_data %&gt;&#x000A;  &lt;%= form.file_field :profile_image %&gt;&#x000A;  &lt;%= form.text_field :profile_image_remote_url %&gt;&#x000A;&lt;% end %&gt;</pre>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
